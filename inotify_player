#!/usr/bin/env python3
#

import sys
from optparse import OptionParser
from pathlib import Path
import json
import inotify.adapters
import inotify.constants
import subprocess
import _thread
from queue import Queue
import time


def main():
    capturedir = parse_config()
    read_queue = Queue()
    now_playing = Queue()
    now_playing.put({"audio": "idle"})
    try:
        _thread.start_new_thread(inotify_thread, (capturedir, read_queue))
    except:
        print("Error: unable to start inotify_thread")
        sys.exit(1)
    try:
        _thread.start_new_thread(play_file, (read_queue, now_playing))
    except:
        print("Error: unable to start play_file_thread")
        sys.exit(1)
    while True:
        # read_queue.put({"audio": media_audio, "freq": media_meta['freq'], "start": media_meta['start_time'], "srcList": media_meta['srcList']})
        display = now_playing.get()
        print("\033c", end="")
        if display["audio"] != "idle":
            print(display)
        else:
            print("idle")


def parse_config():
    parser = OptionParser()
    parser.add_option("-c", "--config", dest="filename",
                      help="trunk-recorder config file", metavar="FILE")
    parser.add_option("-q", "--quiet",
                      action="store_false", dest="verbose", default=True,
                      help="don't print status messages to stdout")

    (options, args) = parser.parse_args()

    if options.filename is None:
        print("Please provide a trunk-recorder config file.")
        sys.exit(1)

    path = Path(options.filename)
    if path.is_file():
        # print(f'The file {options.filename} exists, reading...')
        pass
    else:
        print(f'The file {options.filename} does not exist')
        sys.exit(1)

    config_file = open(options.filename,)
    config = json.load(config_file)
    config_file.close()

    return config['captureDir']


def inotify_thread(capturedir, read_queue):
    # print("INOTIFY_THREAD: Setting up InotifyTree on {}...".format(capturedir))
    i = inotify.adapters.InotifyTree(
            capturedir, mask=inotify.constants.IN_CLOSE_WRITE
            )
    # print("INOTIFY_THREAD: Waiting on inotify events...")

    # while True:
    for event in i.event_gen(yield_nones=False):
        (_, type_names, path, filename) = event

        if type_names == ['IN_CLOSE_WRITE'] and filename.endswith('.m4a'):
            # print("INOTIFY_THREAD: Queuing {}/{}".format(path, filename))
            # this will need a rewrite if we support reading on modify
            media_audio = "{}/{}".format(path, filename)
            media_json = open(media_audio.replace('m4a', 'json'))
            media_meta = json.load(media_json)
            media_json.close()
            # media_freq_tag = media_meta['doesnotexist']
            read_queue.put({"audio": media_audio, "freq": media_meta['freq'], "start": media_meta['start_time'], "srcList": media_meta['srcList']})
            read_queue.put({"audio": "idle"})


def play_file(read_queue, now_playing):
    # print("PLAY_FILE_THREAD: started")
    while True:
        # print("PLAY_FILE_THREAD: Waiting for item...")
        media = read_queue.get()
        # print("PLAY_FILE_THREAD: Got a file to play, {}".format(media["audio"]))
        now_playing.put(media)
        if media["audio"] != "idle":
            subprocess.run(
                    ["ffplay", "-hide_banner", "-autoexit", "-vn", "-nodisp", media["audio"]],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.STDOUT
                    )


if __name__ == "__main__":
    main()
