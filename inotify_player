#!/usr/bin/env python3
#

import sys
from optparse import OptionParser
from pathlib import Path
import json
import inotify.adapters
import inotify.constants
import subprocess
import _thread
from queue import Queue
import datetime


def main():
    capturedir = parse_config()
    read_queue = Queue()
    now_playing = Queue()
    now_playing.put({"audio": "idle"})
    try:
        _thread.start_new_thread(inotify_thread, (capturedir, read_queue))
    except:
        print("Error: unable to start inotify_thread")
        sys.exit(1)
    try:
        _thread.start_new_thread(play_file, (read_queue, now_playing))
    except:
        print("Error: unable to start play_file_thread")
        sys.exit(1)
    while True:
        display = now_playing.get()
        show_it(display, read_queue.qsize())


def show_it(meta, q):
    print("\033c", end="")
    currtime = datetime.datetime.now()
    # .strftime("%Y-%m-%d %H:%M:%S")
    if meta["audio"] == "idle":
        meta = {"audio": "idle", "freq_tag": "idle", "freq": "000000000", "start": currtime, "srcList": "idle"}
    print("Last Update Time : {}".format(currtime.strftime("%Y-%m-%d %H:%M:%S")))
    print("Recording  Time  : {}".format(meta["start"].strftime("%Y-%m-%d %H:%M:%S")))
    print("Queue: {}\t\tDelay: {}".format(q, (currtime - meta["start"])))
    print("--------------------------------------")
    print("{} Hz : {}".format(meta["freq"], meta["freq_tag"]))
    print(meta)


def parse_config():
    parser = OptionParser()
    parser.add_option("-c", "--config", dest="filename",
                      help="trunk-recorder config file", metavar="FILE")
    parser.add_option("-q", "--quiet",
                      action="store_false", dest="verbose", default=True,
                      help="don't print status messages to stdout")

    (options, args) = parser.parse_args()

    if options.filename is None:
        print("Please provide a trunk-recorder config file.")
        sys.exit(1)

    path = Path(options.filename)
    if path.is_file():
        # print(f'The file {options.filename} exists, reading...')
        pass
    else:
        print(f'The file {options.filename} does not exist')
        sys.exit(1)

    config_file = open(options.filename,)
    config = json.load(config_file)
    config_file.close()

    return config['captureDir']


def inotify_thread(capturedir, read_queue):
    # print("INOTIFY_THREAD: Setting up InotifyTree on {}...".format(capturedir))
    i = inotify.adapters.InotifyTree(
            capturedir, mask=inotify.constants.IN_CLOSE_WRITE
            )
    # print("INOTIFY_THREAD: Waiting on inotify events...")

    # while True:
    for event in i.event_gen(yield_nones=False):
        (_, type_names, path, filename) = event

        if type_names == ['IN_CLOSE_WRITE'] and filename.endswith('.m4a'):
            # print("INOTIFY_THREAD: Queuing {}/{}".format(path, filename))
            # this will need a rewrite if we support reading on modify
            media_audio = "{}/{}".format(path, filename)
            media_json = open(media_audio.replace('m4a', 'json'))
            media_meta = json.load(media_json)
            media_json.close()
            read_queue.put({"audio": media_audio, "freq": media_meta['freq'], "freq_tag": "Unavailable", "start": media_meta['start_time'], "srcList": media_meta['srcList']})
            read_queue.put({"audio": "idle"})


def play_file(read_queue, now_playing):
    # print("PLAY_FILE_THREAD: started")
    while True:
        # print("PLAY_FILE_THREAD: Waiting for item...")
        media = read_queue.get()
        # print("PLAY_FILE_THREAD: Got a file to play, {}".format(media["audio"]))
        now_playing.put(media)
        if media["audio"] != "idle":
            subprocess.run(
                    ["ffplay", "-hide_banner", "-autoexit", "-vn", "-nodisp", media["audio"]],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.STDOUT
                    )


if __name__ == "__main__":
    main()
