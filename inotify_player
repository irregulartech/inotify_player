#!/usr/bin/env python3
#

import sys
from optparse import OptionParser
from pathlib import Path
import json
import inotify.adapters
import inotify.constants
import subprocess
import _thread
from queue import Queue
import datetime
import time


def main():
    capturedir = parse_config()
    read_queue = Queue()
    now_playing = Queue()
    now_playing.put({'audio': 'idle', 'start': datetime.datetime.now().timestamp(), 'srcList': [{'src': 0, 'tag': ''}], 'talkgroup_tag': 'idle'})
    try:
        _thread.start_new_thread(inotify_thread, (capturedir, read_queue))
    except:
        print("Error: unable to start inotify_thread")
        sys.exit(1)
    try:
        _thread.start_new_thread(play_file, (read_queue, now_playing))
    except:
        print("Error: unable to start play_file_thread")
        sys.exit(1)
    while True:
        display = now_playing.get()
        # Prime the pump by displaying everything except the unit tag as that may not be known at the start of the transmission
        show_it(display, {'src': 0, 'tag': ''}, read_queue.qsize())
        lasttime = display['start']
        for src in display['srcList']:
            if src['src'] != 0:
                sleeptime = src['time'] - lasttime
                time.sleep(sleeptime)
                lasttime = lasttime + sleeptime
                show_it(display, src, read_queue.qsize())


def show_it(meta, src, q):
    print("\033c", end="")
    # print(meta)
    # print(src)
    # print(q)
    currtime = datetime.datetime.now()
    if meta['audio'] == 'idle':
        meta = {'audio': 'idle', 'freq_tag': 'idle', 'freq': '000000000', 'start': currtime.timestamp(), 'tid': 'idle', 'talkgroup_tag': 'idle', 'srcList': 'idle'}
    print('Last Update Time : {}'.format(currtime.strftime("%Y-%m-%d %H:%M:%S")))
    print('Recording  Time  : {}'.format(datetime.datetime.fromtimestamp(meta['start']).strftime("%Y-%m-%d %H:%M:%S")))
    print('Queue: {}\t\tDelay: {}'.format(q, (currtime - datetime.datetime.fromtimestamp(meta['start']))))
    print('--------------------------------------')
    print('{} Hz : {}'.format(meta['freq'], meta['talkgroup_tag']))
    print('TG: {}'.format(meta['tid']))
    if src['tag'] == "":
        src['tag'] = "Unknown"
    print('UID: {} [{}]'.format(src['tag'], src['src']))


def parse_config():
    parser = OptionParser()
    parser.add_option("-c", "--config", dest="filename",
                      help="trunk-recorder config file", metavar="FILE")
    parser.add_option("-q", "--quiet",
                      action="store_false", dest="verbose", default=True,
                      help="don't print status messages to stdout")

    (options, args) = parser.parse_args()

    if options.filename is None:
        print("Please provide a trunk-recorder config file.")
        sys.exit(1)

    path = Path(options.filename)
    if path.is_file():
        # print(f'The file {options.filename} exists, reading...')
        pass
    else:
        print(f'The file {options.filename} does not exist')
        sys.exit(1)

    config_file = open(options.filename,)
    config = json.load(config_file)
    config_file.close()

    return config['captureDir']


def inotify_thread(capturedir, read_queue):
    # print("INOTIFY_THREAD: Setting up InotifyTree on {}...".format(capturedir))
    i = inotify.adapters.InotifyTree(
            capturedir, mask=inotify.constants.IN_CLOSE_WRITE
            )
    # print("INOTIFY_THREAD: Waiting on inotify events...")

    # while True:
    for event in i.event_gen(yield_nones=False):
        (_, type_names, path, filename) = event

        if type_names == ['IN_CLOSE_WRITE'] and filename.endswith('.m4a'):
            # print("INOTIFY_THREAD: Queuing {}/{}".format(path, filename))
            # this will need a rewrite if we support reading on modify
            media_audio = "{}/{}".format(path, filename)
            media_json = open(media_audio.replace('m4a', 'json'))
            media_meta = json.load(media_json)
            media_json.close()
            read_queue.put({"audio": media_audio, "freq": media_meta['freq'], 'talkgroup_tag': media_meta['talkgroup_tag'], "start": media_meta['start_time'], "tid": media_meta['talkgroup'], "srcList": media_meta['srcList']})
            read_queue.put({"audio": "idle", 'start': datetime.datetime.now().timestamp(), 'srcList': [{'src': 0, 'tag': ''}]})


def play_file(read_queue, now_playing):
    # print("PLAY_FILE_THREAD: started")
    while True:
        # print("PLAY_FILE_THREAD: Waiting for item...")
        media = read_queue.get()
        # print("PLAY_FILE_THREAD: Got a file to play, {}".format(media["audio"]))
        now_playing.put(media)
        if media["audio"] != "idle":
            subprocess.run(
                    ["ffplay", "-hide_banner", "-autoexit", "-vn", "-nodisp", media["audio"]],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.STDOUT
                    )


if __name__ == "__main__":
    main()
