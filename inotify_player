#!/usr/bin/env python3
#

import sys
from optparse import OptionParser
from pathlib import Path
import json
import inotify.adapters
import inotify.constants
import subprocess
import _thread
from queue import Queue


def main():
    capturedir = parse_config()
    read_queue = Queue()
    # try:
    #    _thread.start_new_thread(inotify_thread, (capturedir, read_queue))
    # except:
    #    print("Error: unable to start inotify_thread")
    #    sys.exit(1)
    try:
        _thread.start_new_thread(play_file, (read_queue,))
    except:
        print("Error: unable to start play_file_thread")
        sys.exit(1)
    #I want this to run as a thread and it's commented out above because it doesn't work
    inotify_thread(capturedir, read_queue)
    # while True:
    #    pass


def parse_config():
    parser = OptionParser()
    parser.add_option("-c", "--config", dest="filename",
                      help="trunk-recorder config file", metavar="FILE")
    parser.add_option("-q", "--quiet",
                      action="store_false", dest="verbose", default=True,
                      help="don't print status messages to stdout")

    (options, args) = parser.parse_args()

    if options.filename is None:
        print("Please provide a trunk-recorder config file.")
        sys.exit(1)

    path = Path(options.filename)
    if path.is_file():
        # print(f'The file {options.filename} exists, reading...')
        pass
    else:
        print(f'The file {options.filename} does not exist')
        sys.exit(1)

    f = open(options.filename,)
    config = json.load(f)
    f.close()

    return config['captureDir']


def inotify_thread(capturedir, read_queue):
    # print("INOTIFY_THREAD: Setting up InotifyTree on {}...".format(capturedir))
    #when run as a thread, the below line doesn't error, or seem to ever return.
    i = inotify.adapters.InotifyTree(
            capturedir, mask=inotify.constants.IN_CLOSE_WRITE
            )
    # print("INOTIFY_THREAD: Waiting on inotify events...")

    # while True:
    for event in i.event_gen(yield_nones=False):
        (_, type_names, path, filename) = event

        if type_names == ['IN_CLOSE_WRITE'] and filename.endswith('.m4a'):
            # print("INOTIFY_THREAD: Queuing {}/{}".format(path, filename))
            read_queue.put("{}/{}".format(path, filename))


def play_file(read_queue):
    # print("PLAY_FILE_THREAD: started")
    while True:
        # print("PLAY_FILE_THREAD: Waiting for item...")
        play_filename = read_queue.get()
        # print("PLAY_FILE_THREAD: Got a file to play, {}".format(play_filename))
        subprocess.run(
                ["ffplay", "-hide_banner", "-autoexit", "-vn", "-nodisp", play_filename],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.STDOUT
                )


if __name__ == "__main__":
    main()
